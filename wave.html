<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Physics Simulation Suite</title>
  <style>
    /* CSS Variables for consistent theming */
    :root {
      --primary-color: #4a6bff;
      --secondary-color: #ff6b6b;
      --accent-color: #6bff6b;
      --dark-color: #333;
      --light-color: #f8f9fa;
      --border-radius: 10px;
      --box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
      --input-bg: #f0f4f8;
      --button-hover-scale: 1.03;
      --button-active-scale: 0.98;
    }

    /* Basic reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* Body styling for overall page appearance */
    body {
      font-family: 'Inter', sans-serif; /* Using Inter font as specified */
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
      color: var(--dark-color);
      line-height: 1.6;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start; /* Align to top to prevent excessive vertical centering */
      min-height: 100vh; /* Ensure body takes full viewport height */
    }

    /* Main container for the simulation */
    .container {
      max-width: 1200px; /* Adjusted max-width for overall suite */
      width: 100%;
      margin: 0 auto;
      background: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 30px;
      margin-top: 20px;
    }

    /* Header styling */
    header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 15px;
      border-bottom: 1px solid #eee;
    }

    h1 {
      color: var(--primary-color);
      margin-bottom: 10px;
      font-size: 2.5rem;
    }

    .subtitle {
      color: #666;
      font-size: 1.2rem;
    }

    /* Tabs styling */
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      flex-wrap: wrap; /* Allow tabs to wrap on smaller screens */
      gap: 10px; /* Space between tabs */
    }

    .tab-btn {
      padding: 12px 24px;
      background: white;
      border: none;
      border-radius: 30px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      font-weight: 600;
      flex-shrink: 0; /* Prevent buttons from shrinking too much */
    }

    .tab-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    .tab-btn.active {
      background: var(--primary-color);
      color: white;
    }

    /* Tab content styling */
    .tab-content {
      display: none;
      background: white;
      padding: 30px;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      margin-bottom: 30px;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Simulation container specific styling */
    .simulation-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .simulation-title {
      color: var(--primary-color);
      margin-bottom: 20px;
      text-align: center;
      font-size: 1.8rem;
    }

    /* Controls section layout */
    .controls {
      width: 100%;
      max-width: 800px;
      margin-bottom: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
      padding: 15px;
      border-radius: var(--border-radius);
      background: var(--input-bg);
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
    }

    /* Styling for each control group (label + input) */
    .control-group {
      margin-bottom: 0;
    }

    .control-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      color: #555;
      font-size: 0.95rem;
    }

    .control-group input[type="number"],
    .control-group input[type="range"],
    .control-group select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      font-size: 16px;
      background: white;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .control-group input[type="number"]:focus,
    .control-group select:focus {
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(74, 107, 255, 0.2);
        outline: none;
    }

    /* Range input specific styling */
    .control-group input[type="range"] {
      padding: 0;
      height: 25px;
      -webkit-appearance: none;
      appearance: none;
      background: #e0e0e0;
      outline: none;
      border-radius: 10px;
      cursor: pointer;
    }
    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: grab;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background 0.3s ease, transform 0.2s ease;
    }
    .control-group input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: grab;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background 0.3s ease, transform 0.2s ease;
    }
    .control-group input[type="range"]::-webkit-slider-thumb:active {
        transform: scale(1.1);
    }
    .control-group input[type="range"]::-moz-range-thumb:active {
        transform: scale(1.1);
    }

    /* Button group styling */
    .button-group {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    /* Button base styling */
    button {
      padding: 12px 25px;
      border: none;
      border-radius: 30px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }

    /* Primary button color */
    button.primary {
      background-color: var(--primary-color);
      color: white;
    }

    /* Secondary button color */
    button.secondary {
      background-color: var(--secondary-color);
      color: white;
    }

    /* Button hover and active states for interactive feedback */
    button:hover {
      transform: scale(var(--button-hover-scale));
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    button:active {
      transform: scale(var(--button-active-scale));
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
    }

    /* Ripple effect for buttons */
    button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 5px;
      height: 5px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      opacity: 0;
      transform: scale(1) translate(-50%, -50%);
      transition: transform 0.5s, opacity 0.5s;
    }

    button:active::after {
      transform: scale(15) translate(-50%, -50%);
      opacity: 1;
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
    }

    /* Canvas area for simulation drawing */
    .simulation-area {
      width: 100%;
      max-width: 800px;
      height: 450px;
      margin: 20px 0;
      background: #f8f9fa;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, #e0f2f7 0%, #ffffff 100%);
      border-radius: var(--border-radius);
    }

    /* Info panel styling */
    .info-panel {
      background: white;
      padding: 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      margin-top: 20px;
      width: 100%;
      max-width: 800px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }

    .info-item {
      font-size: 1.1rem;
      line-height: 1.4;
      background: var(--input-bg);
      padding: 10px 15px;
      border-radius: var(--border-radius);
      border: 1px solid #e0e0e0;
    }

    .info-item span {
      font-weight: 600;
      color: var(--primary-color);
      display: block;
      margin-top: 5px;
      font-size: 1.2rem;
    }

    /* Collapsible sections for better organization (only used for Sound Wave tab now) */
    .collapsible-header {
        background-color: var(--primary-color);
        color: white;
        padding: 10px 20px;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: bold;
        margin-top: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background-color 0.3s ease;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .collapsible-header:hover {
        background-color: #3b5ad8;
    }

    .collapsible-header .arrow {
        font-size: 1.2rem;
        transition: transform 0.3s ease;
    }

    .collapsible-header.collapsed .arrow {
        transform: rotate(-90deg);
    }

    .collapsible-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.5s ease-out;
        padding: 0 10px;
        background: var(--input-bg);
        border-bottom-left-radius: var(--border-radius);
        border-bottom-right-radius: var(--border-radius);
        box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
    }

    .collapsible-content.expanded {
        max-height: 500px;
        padding: 15px;
    }

    /* Animation for sound medium particles */
    .particle {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 50%;
        width: 5px;
        height: 5px;
        transform: translate(-50%, -50%);
    }

    .play-status {
      margin-top: 10px;
      font-size: 1rem;
      font-weight: bold;
      color: var(--secondary-color);
      text-align: center;
      min-height: 20px;
    }

    /* Loading spinner for Tone.js */
    .loading-spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid var(--primary-color);
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 10px auto;
        display: none;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      .container {
        padding: 15px;
        margin-top: 10px;
      }
      .controls, .info-panel {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      .simulation-area {
        height: 300px;
      }
      h1 {
        font-size: 1.8rem;
      }
      .subtitle {
        font-size: 1rem;
      }
      .simulation-title {
        font-size: 1.5rem;
      }
      .info-item {
        font-size: 0.95rem;
      }
      .info-item span {
        font-size: 1.05rem;
      }
      .tabs {
        flex-wrap: wrap;
        justify-content: flex-start;
      }
      .tab-btn {
        padding: 10px 15px;
        font-size: 0.9rem;
      }
    }

    @media (max-width: 480px) {
        .button-group {
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
        }
        .tabs {
            flex-direction: column;
            align-items: stretch;
        }
        .tab-btn {
            width: 100%;
            margin-bottom: 5px;
        }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Physics Simulation Suite</h1>
      <p class="subtitle">Interactive physics simulations for education and exploration</p>
    </header>

    <div class="tabs">
      <button class="tab-btn active" data-tab="soundWave">Sound Wave</button>
      <button class="tab-btn" data-tab="interference">Interference</button>
      <button class="tab-btn" data-tab="diffraction">Diffraction</button>
      <button class="tab-btn" data-tab="dopplerEffect">Doppler Effect</button>
    </div>

    <!-- Sound Wave Tab -->
    <div id="soundWave" class="tab-content active">
        <div class="simulation-container">
            <h2 class="simulation-title">Sound Wave Visualization</h2>

            <div class="controls">
                <div class="control-group">
                    <label for="soundWave_frequency">Frequency (Hz):</label>
                    <input type="number" id="soundWave_frequency" min="20" max="2000" value="150" step="10">
                </div>
                <div class="control-group">
                    <label for="soundWave_amplitude">Amplitude:</label>
                    <input type="number" id="soundWave_amplitude" min="10" max="80" value="40" step="5">
                </div>
                <div class="control-group">
                    <label for="soundWave_speed">Wave Speed (px/s):</label>
                    <input type="number" id="soundWave_speed" min="50" max="400" value="100" step="10">
                </div>
                <div class="control-group">
                    <label for="soundWave_waveShape">Wave Shape:</label>
                    <select id="soundWave_waveShape">
                        <option value="sine">Sine</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="triangle">Triangle</option>
                    </select>
                </div>
            </div>

            <div class="button-group">
                <button class="primary" id="soundWave_playSoundBtn">Play Sound</button>
                <button class="secondary" id="soundWave_stopSoundBtn">Stop Sound</button>
            </div>
            <div class="play-status" id="soundWave_playStatus"></div>
            <div class="loading-spinner" id="soundWave_loadingSpinner"></div>

            <div class="simulation-area">
                <canvas id="soundWave_canvas"></canvas>
                <div id="soundWave_particleContainer"></div>
            </div>

            <div class="info-panel" id="soundWave_info">
                <div class="info-item">Wavelength: <span id="soundWave_wavelength">?</span> px</div>
                <div class="info-item">Period: <span id="soundWave_period">?</span> s</div>
                <div class="info-item">Frequency: <span id="soundWave_infoFrequency">?</span> Hz</div>
                <div class="info-item">Amplitude: <span id="soundWave_infoAmplitude">?</span></div>
            </div>
        </div>
    </div>

    <!-- Interference Tab -->
    <div id="interference" class="tab-content">
        <div class="simulation-container">
            <h2 class="simulation-title">Wave Interference</h2>

            <div class="controls">
                <div class="control-group">
                    <label for="interference_frequency1">Source 1 Freq (Hz):</label>
                    <input type="number" id="interference_frequency1" min="10" max="200" value="30" step="1">
                </div>
                <div class="control-group">
                    <label for="interference_amplitude1">Source 1 Ampl:</label>
                    <input type="number" id="interference_amplitude1" min="10" max="80" value="40" step="5">
                </div>
                <div class="control-group">
                    <label for="interference_frequency2">Source 2 Freq (Hz):</label>
                    <input type="number" id="interference_frequency2" min="10" max="200" value="30" step="1">
                </div>
                <div class="control-group">
                    <label for="interference_amplitude2">Source 2 Ampl:</label>
                    <input type="number" id="interference_amplitude2" min="0" max="80" value="40" step="5">
                </div>
                <div class="control-group">
                    <label for="interference_phaseDiff2">Source 2 Phase Diff (Â°):</label>
                    <input type="number" id="interference_phaseDiff2" min="0" max="360" value="0" step="5">
                </div>
                <div class="control-group">
                    <label for="interference_sourceDistance">Source Distance (px):</label>
                    <input type="number" id="interference_sourceDistance" min="50" max="200" value="100" step="10">
                </div>
                <div class="control-group">
                  <label for="interference_waveSpeed">Wave Speed (px/s):</label>
                  <input type="number" id="interference_waveSpeed" min="50" max="400" value="100" step="10">
                </div>
            </div>

            <div class="simulation-area">
                <canvas id="interference_canvas"></canvas>
            </div>

            <div class="info-panel" id="interference_info">
                <div class="info-item">Source 1 Wavelength: <span id="interference_wavelength1">?</span> px</div>
                <div class="info-item">Source 2 Wavelength: <span id="interference_wavelength2">?</span> px</div>
            </div>
        </div>
    </div>

    <!-- Diffraction Tab -->
    <div id="diffraction" class="tab-content">
      <div class="simulation-container">
        <h2 class="simulation-title">Wave Diffraction (Placeholder)</h2>
        <div class="controls">
          <div class="control-group">
            <label for="diffraction_frequency">Wave Frequency (Hz):</label>
            <input type="number" id="diffraction_frequency" min="1" max="100" value="20" step="1">
          </div>
          <div class="control-group">
            <label for="diffraction_amplitude">Wave Amplitude:</label>
            <input type="number" id="diffraction_amplitude" min="10" max="80" value="40" step="5">
          </div>
          <div class="control-group">
            <label for="diffraction_slitWidth">Slit Width (px):</label>
            <input type="number" id="diffraction_slitWidth" min="10" max="150" value="50" step="5">
          </div>
        </div>
        <div class="simulation-area">
            <canvas id="diffraction_canvas"></canvas>
        </div>
        <div class="info-panel" id="diffraction_info">
            <div class="info-item">Wavelength: <span id="diffraction_wavelength">?</span> px</div>
            <div class="info-item">Slit Width: <span id="diffraction_infoSlitWidth">?</span> px</div>
        </div>
      </div>
    </div>

    <!-- Doppler Effect Tab -->
    <div id="dopplerEffect" class="tab-content">
        <div class="simulation-container">
            <h2 class="simulation-title">Doppler Effect Visualization</h2>

            <div class="controls">
                <div class="control-group">
                    <label for="doppler_sourceFrequency">Source Frequency (Hz):</label>
                    <input type="number" id="doppler_sourceFrequency" min="50" max="1000" value="440" step="10">
                </div>
                <div class="control-group">
                    <label for="doppler_waveSpeed">Wave Speed (px/s):</label>
                    <input type="number" id="doppler_waveSpeed" min="100" max="500" value="200" step="10">
                </div>
                <div class="control-group">
                    <label for="doppler_sourceVelocity">Source Velocity (px/s):</label>
                    <input type="number" id="doppler_sourceVelocity" min="-100" max="100" value="0" step="5">
                </div>
                <div class="control-group">
                  <label for="doppler_amplitude">Amplitude:</label>
                  <input type="number" id="doppler_amplitude" min="10" max="80" value="40" step="5">
                </div>
            </div>

            <div class="button-group">
                <button class="primary" id="doppler_playSoundBtn">Play Sound</button>
                <button class="secondary" id="doppler_stopSoundBtn">Stop Sound</button>
            </div>
            <div class="play-status" id="doppler_playStatus"></div>
            <div class="loading-spinner" id="doppler_loadingSpinner"></div>

            <div class="simulation-area">
                <canvas id="dopplerEffect_canvas"></canvas>
            </div>

            <div class="info-panel" id="dopplerEffect_info">
                <div class="info-item">Observed Frequency: <span id="doppler_observedFrequency">?</span> Hz</div>
                <div class="info-item">Source Wavelength: <span id="doppler_sourceWavelength">?</span> px</div>
                <div class="info-item">Apparent Wavelength: <span id="doppler_apparentWavelength">?</span> px</div>
            </div>
        </div>
    </div>

  </div>

  <!-- Tone.js library -->
  <script src="https://unpkg.com/tone@14.7.58/build/Tone.js"></script>

  <script>
    // --- Global Variables for Tab Management and General Utilities ---
    let currentAnimationId = null; // Stores the requestAnimationFrame ID for the active simulation
    let activeSimulation = null; // Stores the currently active simulation object

    // Common utility for info panels (can be shared if structure is consistent)
    function updateInfoPanel(panelId, data) {
        for (const key in data) {
            const element = document.getElementById(panelId + '_' + key);
            if (element) {
                element.textContent = data[key];
            }
        }
    }

    /**
     * Toggles the visibility and expansion of a collapsible content section.
     * @param {string} headerId - The ID of the collapsible header element.
     * @param {string} contentId - The ID of the collapsible content element.
     */
    function setupCollapsible(headerId, contentId) {
        const header = document.getElementById(headerId);
        const content = document.getElementById(contentId);

        if (!header || !content) return;

        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            content.classList.toggle('expanded');
        });
        header.classList.add('collapsed'); // Initially collapse
    }

    // --- Sound Wave Simulation Logic ---
    const soundWaveSim = {
        id: 'soundWave',
        canvasId: 'soundWave_canvas',
        ctx: null,
        canvas: null,
        phase: 0,
        particleElements: [],
        numParticles: 80,
        oscillator: null,
        gainNode: null,
        audioContextReady: false,
        isPlaying: false,

        init: function() {
            this.canvas = document.getElementById(this.canvasId);
            if (!this.canvas) return; // Exit if canvas not found
            this.ctx = this.canvas.getContext('2d');

            const parentContainer = this.canvas.closest('.simulation-area');
            if (parentContainer) {
                this.canvas.width = parentContainer.offsetWidth;
                this.canvas.height = parentContainer.offsetHeight;
            }

            const particleContainer = document.getElementById('soundWave_particleContainer');
            if (particleContainer) {
                particleContainer.innerHTML = '';
                this.particleElements = [];
                for (let i = 0; i < this.numParticles; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particleContainer.appendChild(particle);
                    this.particleElements.push(particle);
                }
            }
            this.draw();
            this.setupListeners();
            document.getElementById('soundWave_stopSoundBtn').disabled = true;
            this.updateInfoPanel();
        },

        draw: function() {
            if (!this.ctx) return;
            const width = this.canvas.width;
            const height = this.canvas.height;
            this.ctx.clearRect(0, 0, width, height);

            const frequency = parseFloat(document.getElementById('soundWave_frequency').value);
            const amplitude = parseFloat(document.getElementById('soundWave_amplitude').value);
            const speed = parseFloat(document.getElementById('soundWave_speed').value);
            const waveShape = document.getElementById('soundWave_waveShape').value;
            const centerY = height / 2;

            const wavelength = speed / frequency;
            if (wavelength === 0 || !isFinite(wavelength)) return; // Avoid division by zero or infinite wavelength

            this.ctx.beginPath();
            this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
            this.ctx.lineWidth = 3;

            for (let x = 0; x <= width; x++) {
                let y;
                const angle = (x * Math.PI * 2 / wavelength) + this.phase;
                if (waveShape === 'sine') {
                    y = amplitude * Math.sin(angle);
                } else if (waveShape === 'square') {
                    y = amplitude * (Math.sin(angle) >= 0 ? 1 : -1);
                } else if (waveShape === 'sawtooth') {
                    y = amplitude * (2 * ((angle / (2 * Math.PI)) % 1) - 1);
                } else if (waveShape === 'triangle') {
                    y = amplitude * (Math.abs((angle / Math.PI) % 2) - 1);
                }
                const yCombined = centerY + y;
                if (x === 0) {
                    this.ctx.moveTo(x, yCombined);
                } else {
                    this.ctx.lineTo(x, yCombined);
                }
            }
            this.ctx.stroke();

            this.phase += (speed / (frequency * wavelength)) * 0.05;
            if (this.phase > Math.PI * 2) this.phase -= Math.PI * 2;

            this.particleElements.forEach((particle, index) => {
                const particleX = (width / this.numParticles) * index;
                let yParticle;
                const angleParticle = (particleX * Math.PI * 2 / wavelength) + this.phase;
                 if (waveShape === 'sine') {
                    yParticle = amplitude * Math.sin(angleParticle);
                } else if (waveShape === 'square') {
                    yParticle = amplitude * (Math.sin(angleParticle) >= 0 ? 1 : -1);
                } else if (waveShape === 'sawtooth') {
                    yParticle = amplitude * (2 * ((angleParticle / (2 * Math.PI)) % 1) - 1);
                } else if (waveShape === 'triangle') {
                    yParticle = amplitude * (Math.abs((angleParticle / Math.PI) % 2) - 1);
                }
                particle.style.left = `${particleX}px`;
                particle.style.top = `${centerY + yParticle}px`;
            });

            this.updateInfoPanel();
        },

        startAudio: async function() {
            if (!this.audioContextReady) {
                await Tone.start();
                this.audioContextReady = true;
            }

            if (this.oscillator) {
                this.oscillator.stop();
                this.oscillator.dispose();
            }
            if (this.gainNode) {
                this.gainNode.dispose();
            }

            const frequency = parseFloat(document.getElementById('soundWave_frequency').value);
            const amplitude = parseFloat(document.getElementById('soundWave_amplitude').value);
            const waveShape = document.getElementById('soundWave_waveShape').value;

            this.gainNode = new Tone.Gain(0).toDestination();
            this.oscillator = new Tone.Oscillator(frequency, waveShape).connect(this.gainNode);

            const scaledAmplitude = amplitude / 80;
            this.gainNode.gain.rampTo(scaledAmplitude, 0.1);

            this.oscillator.start();
            this.isPlaying = true;
            document.getElementById('soundWave_playStatus').textContent = 'Sound Playing...';
            document.getElementById('soundWave_playSoundBtn').disabled = true;
            document.getElementById('soundWave_stopSoundBtn').disabled = false;
        },

        stopAudio: function() {
            if (this.oscillator) {
                this.gainNode.gain.cancelScheduledValues(Tone.context.currentTime); // Cancel any pending ramps
                this.gainNode.gain.setValueAtTime(0, Tone.context.currentTime); // Set gain to 0 instantly
                this.oscillator.stop();
                this.oscillator.dispose();
                this.gainNode.dispose();
                this.oscillator = null;
                this.gainNode = null;
                this.isPlaying = false;
                document.getElementById('soundWave_playStatus').textContent = 'Sound Stopped.';
                document.getElementById('soundWave_playSoundBtn').disabled = false;
                document.getElementById('soundWave_stopSoundBtn').disabled = true;
            }
        },

        updateAudioParameters: function() {
            if (!this.isPlaying || !this.oscillator || !this.gainNode) return;
            const frequency = parseFloat(document.getElementById('soundWave_frequency').value);
            const amplitude = parseFloat(document.getElementById('soundWave_amplitude').value);
            const waveShape = document.getElementById('soundWave_waveShape').value;

            // Ensure values are numbers and the AudioParams exist before assigning
            if (!isNaN(frequency) && this.oscillator.frequency) {
                this.oscillator.frequency.value = frequency;
            }
            if (this.oscillator.type) {
                 this.oscillator.type = waveShape;
            }
            if (!isNaN(amplitude) && this.gainNode.gain) {
                this.gainNode.gain.value = amplitude / 80;
            }
        },

        updateInfoPanel: function() {
            const frequency = parseFloat(document.getElementById('soundWave_frequency').value);
            const speed = parseFloat(document.getElementById('soundWave_speed').value);
            const amplitude = parseFloat(document.getElementById('soundWave_amplitude').value);
            const wavelength = speed / frequency;
            const period = 1 / frequency;

            updateInfoPanel('soundWave', {
                wavelength: isFinite(wavelength) ? wavelength.toFixed(2) : 'N/A',
                period: isFinite(period) ? period.toFixed(3) : 'N/A',
                infoFrequency: frequency.toFixed(0),
                infoAmplitude: amplitude.toFixed(0)
            });
        },

        setupListeners: function() {
            document.getElementById('soundWave_frequency').addEventListener('input', () => { this.draw(); this.updateAudioParameters(); });
            document.getElementById('soundWave_amplitude').addEventListener('input', () => { this.draw(); this.updateAudioParameters(); });
            document.getElementById('soundWave_speed').addEventListener('input', () => { this.draw(); this.updateAudioParameters(); });
            document.getElementById('soundWave_waveShape').addEventListener('change', () => { this.draw(); this.updateAudioParameters(); });
            document.getElementById('soundWave_playSoundBtn').addEventListener('click', async () => {
                document.getElementById('soundWave_playStatus').textContent = 'Loading audio...';
                document.getElementById('soundWave_loadingSpinner').style.display = 'block';
                await this.startAudio();
                document.getElementById('soundWave_loadingSpinner').style.display = 'none';
            });
            document.getElementById('soundWave_stopSoundBtn').addEventListener('click', this.stopAudio.bind(this));
        },

        stop: function() {
            this.stopAudio();
            if (this.ctx) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            const particleContainer = document.getElementById('soundWave_particleContainer');
            if (particleContainer) {
                particleContainer.innerHTML = '';
                this.particleElements = [];
            }
        }
    };

    // --- Interference Simulation Logic ---
    const interferenceSim = {
        id: 'interference',
        canvasId: 'interference_canvas',
        ctx: null,
        canvas: null,
        phase: 0,
        // Number of points/lines to draw the interference pattern on the screen
        numPoints: 500,

        init: function() {
            this.canvas = document.getElementById(this.canvasId);
            if (!this.canvas) return;
            this.ctx = this.canvas.getContext('2d');
            const parentContainer = this.canvas.closest('.simulation-area');
            if (parentContainer) {
              this.canvas.width = parentContainer.offsetWidth;
              this.canvas.height = parentContainer.offsetHeight;
            }
            this.draw();
            this.setupListeners();
            this.updateInfoPanel();
        },

        draw: function() {
            if (!this.ctx) return;
            const width = this.canvas.width;
            const height = this.canvas.height;
            this.ctx.clearRect(0, 0, width, height);

            const freq1 = parseFloat(document.getElementById('interference_frequency1').value);
            const ampl1 = parseFloat(document.getElementById('interference_amplitude1').value);
            const freq2 = parseFloat(document.getElementById('interference_frequency2').value);
            const ampl2 = parseFloat(document.getElementById('interference_amplitude2').value);
            const phaseDiff2 = parseFloat(document.getElementById('interference_phaseDiff2').value) * Math.PI / 180;
            const sourceDist = parseFloat(document.getElementById('interference_sourceDistance').value);
            const waveSpeed = parseFloat(document.getElementById('interference_waveSpeed').value);

            const wavelength1 = waveSpeed / freq1;
            const wavelength2 = waveSpeed / freq2;

            const source1X = width / 2 - sourceDist / 2;
            const source2X = width / 2 + sourceDist / 2;
            const sourceY = height / 2; // Sources are horizontally aligned

            // Draw sources
            this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
            this.ctx.beginPath();
            this.ctx.arc(source1X, sourceY, 8, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(source2X, sourceY, 8, 0, Math.PI * 2);
            this.ctx.fill();

            // Animate wave fronts for two sources
            this.ctx.strokeStyle = '#888';
            this.ctx.lineWidth = 1;

            const maxRadius = Math.max(width, height) / 1.5; // Max radius for wave circles

            for (let r = this.phase % wavelength1; r < maxRadius; r += wavelength1) {
                this.ctx.beginPath();
                this.ctx.arc(source1X, sourceY, r, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            for (let r = (this.phase + phaseDiff2) % wavelength2; r < maxRadius; r += wavelength2) {
                this.ctx.beginPath();
                this.ctx.arc(source2X, sourceY, r, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            // Simplified 1D interference pattern along the horizontal center line
            this.ctx.beginPath();
            this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
            this.ctx.lineWidth = 3;

            for (let x = 0; x <= width; x++) {
                const dist1 = Math.abs(x - source1X);
                const dist2 = Math.abs(x - source2X);

                const wave1Val = ampl1 * Math.sin(2 * Math.PI * (dist1 / wavelength1) + this.phase);
                const wave2Val = ampl2 * Math.sin(2 * Math.PI * (dist2 / wavelength2) + this.phase + phaseDiff2);

                const combinedWave = wave1Val + wave2Val;
                const yPos = height / 2 + combinedWave;

                if (x === 0) {
                    this.ctx.moveTo(x, yPos);
                } else {
                    this.ctx.lineTo(x, yPos);
                }
            }
            this.ctx.stroke();

            this.phase += 0.05 * (waveSpeed / (wavelength1)); // Animate based on source 1
            if (this.phase > Math.PI * 2) this.phase -= Math.PI * 2;

            this.updateInfoPanel();
        },

        updateInfoPanel: function() {
            const freq1 = parseFloat(document.getElementById('interference_frequency1').value);
            const freq2 = parseFloat(document.getElementById('interference_frequency2').value);
            const waveSpeed = parseFloat(document.getElementById('interference_waveSpeed').value);

            const wavelength1 = waveSpeed / freq1;
            const wavelength2 = waveSpeed / freq2;

            updateInfoPanel('interference', {
                wavelength1: isFinite(wavelength1) ? wavelength1.toFixed(2) : 'N/A',
                wavelength2: isFinite(wavelength2) ? wavelength2.toFixed(2) : 'N/A',
            });
        },

        setupListeners: function() {
            document.getElementById('interference_frequency1').addEventListener('input', this.draw.bind(this));
            document.getElementById('interference_amplitude1').addEventListener('input', this.draw.bind(this));
            document.getElementById('interference_frequency2').addEventListener('input', this.draw.bind(this));
            document.getElementById('interference_amplitude2').addEventListener('input', this.draw.bind(this));
            document.getElementById('interference_phaseDiff2').addEventListener('input', this.draw.bind(this));
            document.getElementById('interference_sourceDistance').addEventListener('input', this.draw.bind(this));
            document.getElementById('interference_waveSpeed').addEventListener('input', this.draw.bind(this));
        },

        stop: function() {
            if (this.ctx) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            this.phase = 0; // Reset phase for next time it's active
        }
    };

    // --- Diffraction Simulation Logic (Placeholder) ---
    const diffractionSim = {
        id: 'diffraction',
        canvasId: 'diffraction_canvas',
        ctx: null,
        canvas: null,
        phase: 0,

        init: function() {
            this.canvas = document.getElementById(this.canvasId);
            if (!this.canvas) return;
            this.ctx = this.canvas.getContext('2d');
            const parentContainer = this.canvas.closest('.simulation-area');
            if (parentContainer) {
              this.canvas.width = parentContainer.offsetWidth;
              this.canvas.height = parentContainer.offsetHeight;
            }
            this.draw();
            this.setupListeners();
            this.updateInfoPanel();
        },

        draw: function() {
            if (!this.ctx) return;
            const width = this.canvas.width;
            const height = this.canvas.height;
            this.ctx.clearRect(0, 0, width, height);

            const frequency = parseFloat(document.getElementById('diffraction_frequency').value);
            const amplitude = parseFloat(document.getElementById('diffraction_amplitude').value);
            const slitWidth = parseFloat(document.getElementById('diffraction_slitWidth').value);
            const waveSpeed = 100; // Fixed wave speed for placeholder

            const wavelength = waveSpeed / frequency;

            // Draw incoming plane waves
            this.ctx.strokeStyle = '#666';
            this.ctx.lineWidth = 1;
            for (let i = 0; i < width / 5; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, i * 20 + this.phase % 20);
                this.ctx.lineTo(width, i * 20 + this.phase % 20);
                this.ctx.stroke();
            }

            // Draw the slit
            const slitCenterY = height / 2;
            this.ctx.fillStyle = '#333';
            this.ctx.fillRect(width / 3 - 5, 0, 10, slitCenterY - slitWidth / 2); // Top part of barrier
            this.ctx.fillRect(width / 3 - 5, slitCenterY + slitWidth / 2, 10, height - (slitCenterY + slitWidth / 2)); // Bottom part of barrier

            this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
            this.ctx.lineWidth = 2;

            // Simple visualization of wave spreading from slit
            const sourceX = width / 3 + 5; // Just past the slit
            const sourceY = slitCenterY;

            const maxRadius = Math.max(width, height) * 0.7;

            for (let r = this.phase % wavelength; r < maxRadius; r += wavelength) {
                this.ctx.beginPath();
                this.ctx.arc(sourceX, sourceY, r, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            this.phase += 0.5; // Animate waves
            if (this.phase > wavelength) this.phase -= wavelength;

            this.updateInfoPanel();
        },

        updateInfoPanel: function() {
            const frequency = parseFloat(document.getElementById('diffraction_frequency').value);
            const slitWidth = parseFloat(document.getElementById('diffraction_slitWidth').value);
            const waveSpeed = 100; // Fixed for placeholder
            const wavelength = waveSpeed / frequency;

            updateInfoPanel('diffraction', {
                wavelength: isFinite(wavelength) ? wavelength.toFixed(2) : 'N/A',
                infoSlitWidth: slitWidth.toFixed(0)
            });
        },

        setupListeners: function() {
            document.getElementById('diffraction_frequency').addEventListener('input', this.draw.bind(this));
            document.getElementById('diffraction_amplitude').addEventListener('input', this.draw.bind(this));
            document.getElementById('diffraction_slitWidth').addEventListener('input', this.draw.bind(this));
        },

        stop: function() {
            if (this.ctx) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            this.phase = 0;
        }
    };

    // --- Doppler Effect Simulation Logic ---
    const dopplerEffectSim = {
        id: 'dopplerEffect',
        canvasId: 'dopplerEffect_canvas',
        ctx: null,
        canvas: null,
        phase: 0,
        oscillator: null,
        gainNode: null,
        audioContextReady: false,
        isPlaying: false,

        init: function() {
            this.canvas = document.getElementById(this.canvasId);
            if (!this.canvas) return;
            this.ctx = this.canvas.getContext('2d');
            const parentContainer = this.canvas.closest('.simulation-area');
            if (parentContainer) {
              this.canvas.width = parentContainer.offsetWidth;
              this.canvas.height = parentContainer.offsetHeight;
            }
            this.draw();
            this.setupListeners();
            document.getElementById('doppler_stopSoundBtn').disabled = true;
            this.updateInfoPanel();
        },

        draw: function() {
            if (!this.ctx) return;
            const width = this.canvas.width;
            const height = this.canvas.height;
            this.ctx.clearRect(0, 0, width, height);

            const sourceFrequency = parseFloat(document.getElementById('doppler_sourceFrequency').value);
            const waveSpeed = parseFloat(document.getElementById('doppler_waveSpeed').value);
            const sourceVelocity = parseFloat(document.getElementById('doppler_sourceVelocity').value);
            const amplitude = parseFloat(document.getElementById('doppler_amplitude').value);

            // Source position (moving horizontally)
            let sourceX = width / 2 + Math.sin(this.phase * 0.05) * (width / 4); // Oscillating source for visual
            sourceX = Math.max(0, Math.min(width, sourceX)); // Keep source on canvas
            const sourceY = height / 2;

            // Observer position (fixed for simplicity)
            const observerX = width * 0.8;
            const observerY = height / 2;
            this.ctx.fillStyle = 'green';
            this.ctx.beginPath();
            this.ctx.arc(observerX, observerY, 10, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.fillText("Observer", observerX + 15, observerY + 5);


            // Draw moving source
            this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
            this.ctx.beginPath();
            this.ctx.arc(sourceX, sourceY, 12, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.fillText("Source", sourceX - 15, sourceY - 15);


            // Calculate effective wave speed relative to source for wavefronts
            const effectiveWaveSpeedLeft = waveSpeed - sourceVelocity;
            const effectiveWaveSpeedRight = waveSpeed + sourceVelocity;

            // Draw wavefronts
            this.ctx.strokeStyle = '#888';
            this.ctx.lineWidth = 1;

            const maxRadius = Math.max(width, height);
            const timeSinceEmission = performance.now() * 0.001 - this.lastEmissionTime;

            this.wavefronts.forEach(wave => {
                const age = timeSinceEmission - wave.emissionTime;
                if (age > 0) {
                    const radiusLeft = age * effectiveWaveSpeedLeft;
                    const radiusRight = age * effectiveWaveSpeedRight;

                    // Draw circles for wavefronts from source's original emission point
                    this.ctx.beginPath();
                    this.ctx.arc(wave.emissionX, sourceY, radiusLeft, 0, Math.PI * 2);
                    this.ctx.stroke();

                    this.ctx.beginPath();
                    this.ctx.arc(wave.emissionX, sourceY, radiusRight, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            });

            this.phase += 0.05; // Animate source movement and wave emission
            this.emissionTimer += 1;

            const timeForOneWave = 1000 / sourceFrequency; // ms per wave
            if (this.emissionTimer * (1000/60) >= timeForOneWave) { // approx 60fps
                 this.wavefronts.push({
                    emissionX: sourceX,
                    emissionTime: performance.now() * 0.001
                 });
                 this.emissionTimer = 0;
                 // Limit number of wavefronts to prevent performance issues
                 if (this.wavefronts.length > 50) {
                     this.wavefronts.shift();
                 }
            }


            this.updateInfoPanel();
        },
        wavefronts: [], // To store details of emitted wavefronts
        lastEmissionTime: 0,
        emissionTimer: 0,


        startAudio: async function() {
            if (!this.audioContextReady) {
                await Tone.start();
                this.audioContextReady = true;
            }

            if (this.oscillator) {
                this.oscillator.stop();
                this.oscillator.dispose();
            }
            if (this.gainNode) {
                this.gainNode.dispose();
            }

            const sourceFrequency = parseFloat(document.getElementById('doppler_sourceFrequency').value);
            const sourceVelocity = parseFloat(document.getElementById('doppler_sourceVelocity').value);
            const waveSpeed = parseFloat(document.getElementById('doppler_waveSpeed').value);
            const amplitude = parseFloat(document.getElementById('doppler_amplitude').value);

            // Doppler Effect: calculate perceived frequency f' = f * (v_wave / (v_wave - v_source))
            // This is a simplified calculation, assuming observer is stationary
            const observedFrequency = sourceFrequency * (waveSpeed / (waveSpeed - sourceVelocity));

            this.gainNode = new Tone.Gain(0).toDestination();
            this.oscillator = new Tone.Oscillator(observedFrequency, 'sine').connect(this.gainNode);

            const scaledAmplitude = amplitude / 80;
            this.gainNode.gain.rampTo(scaledAmplitude, 0.1);

            this.oscillator.start();
            this.isPlaying = true;
            document.getElementById('doppler_playStatus').textContent = 'Sound Playing...';
            document.getElementById('doppler_playSoundBtn').disabled = true;
            document.getElementById('doppler_stopSoundBtn').disabled = false; /* Fixed here */
        },

        stopAudio: function() {
            if (this.oscillator) {
                this.gainNode.gain.cancelScheduledValues(Tone.context.currentTime); // Cancel any pending ramps
                this.gainNode.gain.setValueAtTime(0, Tone.context.currentTime); // Set gain to 0 instantly
                this.oscillator.stop();
                this.oscillator.dispose();
                this.gainNode.dispose();
                this.oscillator = null;
                this.gainNode = null;
                this.isPlaying = false;
                document.getElementById('doppler_playStatus').textContent = 'Sound Stopped.';
                document.getElementById('doppler_playSoundBtn').disabled = false;
                document.getElementById('doppler_stopSoundBtn').disabled = true;
            }
        },

        updateAudioParameters: function() {
            if (!this.isPlaying || !this.oscillator || !this.gainNode) return;

            const sourceFrequency = parseFloat(document.getElementById('doppler_sourceFrequency').value);
            const sourceVelocity = parseFloat(document.getElementById('doppler_sourceVelocity').value);
            const waveSpeed = parseFloat(document.getElementById('doppler_waveSpeed').value);
            const amplitude = parseFloat(document.getElementById('doppler_amplitude').value);

            const observedFrequency = sourceFrequency * (waveSpeed / (waveSpeed - sourceVelocity));

            // Ensure values are numbers and the AudioParams exist before assigning
            if (!isNaN(observedFrequency) && this.oscillator.frequency) {
                this.oscillator.frequency.value = observedFrequency;
            }
            if (!isNaN(amplitude) && this.gainNode.gain) {
                this.gainNode.gain.value = amplitude / 80;
            }
        },

        updateInfoPanel: function() {
            const sourceFrequency = parseFloat(document.getElementById('doppler_sourceFrequency').value);
            const waveSpeed = parseFloat(document.getElementById('doppler_waveSpeed').value);
            const sourceVelocity = parseFloat(document.getElementById('doppler_sourceVelocity').value);

            const observedFrequency = sourceFrequency * (waveSpeed / (waveSpeed - sourceVelocity));
            const sourceWavelength = waveSpeed / sourceFrequency;
            const apparentWavelength = (waveSpeed - sourceVelocity) / sourceFrequency;


            updateInfoPanel('doppler', {
                observedFrequency: isFinite(observedFrequency) ? observedFrequency.toFixed(2) : 'N/A',
                sourceWavelength: isFinite(sourceWavelength) ? sourceWavelength.toFixed(2) : 'N/A',
                apparentWavelength: isFinite(apparentWavelength) ? apparentWavelength.toFixed(2) : 'N/A'
            });
        },

        setupListeners: function() {
            document.getElementById('doppler_sourceFrequency').addEventListener('input', () => { this.draw(); this.updateAudioParameters(); });
            document.getElementById('doppler_waveSpeed').addEventListener('input', () => { this.draw(); this.updateAudioParameters(); });
            document.getElementById('doppler_sourceVelocity').addEventListener('input', () => { this.draw(); this.updateAudioParameters(); });
            document.getElementById('doppler_amplitude').addEventListener('input', () => { this.draw(); this.updateAudioParameters(); });

            document.getElementById('doppler_playSoundBtn').addEventListener('click', async () => {
                document.getElementById('doppler_playStatus').textContent = 'Loading audio...';
                document.getElementById('doppler_loadingSpinner').style.display = 'block';
                await this.startAudio();
                document.getElementById('doppler_loadingSpinner').style.display = 'none';
            });
            document.getElementById('doppler_stopSoundBtn').addEventListener('click', this.stopAudio.bind(this));
        },

        stop: function() {
            this.stopAudio();
            if (this.ctx) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            this.wavefronts = []; // Clear stored wavefronts
            this.phase = 0;
            this.emissionTimer = 0;
            this.lastEmissionTime = 0;
        }
    };


    // --- Tab Switching Logic ---

    // A map to hold references to simulation objects, keyed by tab ID
    const simulations = {
        'soundWave': soundWaveSim,
        'interference': interferenceSim,
        'diffraction': diffractionSim,
        'dopplerEffect': dopplerEffectSim,
    };

    /**
     * Handles switching between different simulation tabs.
     * @param {string} tabId - The ID of the tab to activate.
     */
    function activateTab(tabId) {
        // Stop any currently active simulation's animations/audio
        if (activeSimulation && typeof activeSimulation.stop === 'function') {
            activeSimulation.stop();
        }
        cancelAnimationFrame(currentAnimationId); // Stop the main animation loop

        // Remove 'active' class from all tabs and content
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

        // Add 'active' class to the selected tab button and content
        document.querySelector(`.tab-btn[data-tab="${tabId}"]`).classList.add('active');
        document.getElementById(tabId).classList.add('active');

        // Initialize and start the selected simulation
        activeSimulation = simulations[tabId];
        if (activeSimulation && typeof activeSimulation.init === 'function') {
            activeSimulation.init(); // Initialize the simulation
            // For canvas-based animations, restart the main animation loop
            startMainAnimationLoop();
        }
    }

    /**
     * The main animation loop that continuously calls the drawing function
     * for the currently active simulation.
     */
    function startMainAnimationLoop(time) {
        if (activeSimulation && activeSimulation.canvas && activeSimulation.ctx) {
            // Check if canvas container size has changed and resize canvas if needed
            const parentContainer = activeSimulation.canvas.closest('.simulation-area');
            if (parentContainer && (activeSimulation.canvas.width !== parentContainer.offsetWidth || activeSimulation.canvas.height !== parentContainer.offsetHeight)) {
                activeSimulation.canvas.width = parentContainer.offsetWidth;
                activeSimulation.canvas.height = parentContainer.offsetHeight;
                activeSimulation.draw(); // Redraw immediately after resize
            }
            activeSimulation.draw(time); // Pass time for some simulations if needed
        }
        currentAnimationId = requestAnimationFrame(startMainAnimationLoop);
    }


    // --- Initialization on Document Load ---
    document.addEventListener('DOMContentLoaded', () => {
        // Setup tab click listeners
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                activateTab(btn.getAttribute('data-tab'));
            });
        });

        // Activate the default tab (Sound Wave) on load
        activateTab('soundWave');
    });

    // Stop audio and animations when the page is unloaded
    window.addEventListener('beforeunload', () => {
        if (activeSimulation && typeof activeSimulation.stop === 'function') {
            activeSimulation.stop();
        }
        cancelAnimationFrame(currentAnimationId);
    });

  </script>
</body>
</html>